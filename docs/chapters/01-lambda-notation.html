<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Chapter 1: Lambda Calculus Notation (Or: Learning the Language)</title>
	<link rel="stylesheet" href="../css/hybrid-style.css">
</head>
<body>
	<div class="nav">
		<a href="../index.html">Home</a>
		<a href="../index.html#chapters">Chapters</a>
	</div>

	<h1>Chapter 1: Lambda Calculus Notation (Or: Learning the Language)</h1>

	<p>Before we start building with lambda calculus, we need to understand its notation. Think of this as learning the grammar of a new language - once you know the rules, everything else falls into place.</p>

	<h2>The Three Building Blocks</h2>

	<p>Lambda calculus has exactly three components:</p>

	<ol>
		<li><strong>Variables:</strong> x, y, z, f, etc.</li>
		<li><strong>Abstraction:</strong> Creating functions (λx.E)</li>
		<li><strong>Application:</strong> Calling functions (f x)</li>
	</ol>

	<p>That's it! Everything we'll build - numbers, booleans, data structures - comes from combining these three simple elements.</p>

	<h2>Variables</h2>

	<p>Variables are just names. They can represent anything - numbers, functions, other variables. In lambda calculus, we typically use single letters:</p>

	<pre><code>x
y
f
g</code></pre>

	<p>Variables have no inherent meaning. The variable x doesn't "mean" anything until we give it a value.</p>

	<h2>Abstraction: Creating Functions</h2>

	<p>The λ (lambda) symbol introduces a function. The syntax is:</p>

	<div class="info-box">
		<strong>λ variable . body</strong><br>
		Example: λx.x
	</div>

	<div style="padding: 40px 20px; margin: 30px 0;">
		<div style="text-align: center; margin-bottom: 50px;">
			<div style="display: inline-flex; align-items: flex-end; gap: 30px; font-size: 42px; font-family: Georgia, serif;">
				<div style="display: flex; flex-direction: column; align-items: center; gap: 15px;">
					<div style="font-size: 11px; font-family: sans-serif; color: #666; font-weight: normal; text-align: center; padding: 6px 12px; background: white; border: 1px solid #6c5ce7; border-radius: 4px;">
						Lambda<br/>symbol
					</div>
					<span style="color: #e74c3c; font-weight: bold;">λ</span>
				</div>
				<div style="display: flex; flex-direction: column; align-items: center; gap: 15px;">
					<div style="font-size: 11px; font-family: sans-serif; color: #666; font-weight: normal; padding: 6px 12px; background: white; border: 1px solid #6c5ce7; border-radius: 4px;">
						Parameter
					</div>
					<span style="color: #2ecc71; font-weight: bold;">x</span>
				</div>
				<div style="display: flex; flex-direction: column; align-items: center; gap: 15px;">
					<div style="font-size: 11px; font-family: sans-serif; color: #666; font-weight: normal; padding: 6px 12px; background: white; border: 1px solid #6c5ce7; border-radius: 4px;">
						Separator
					</div>
					<span style="color: #3498db; font-weight: bold;">.</span>
				</div>
				<div style="display: flex; flex-direction: column; align-items: center; gap: 15px;">
					<div style="font-size: 11px; font-family: sans-serif; color: #666; font-weight: normal; text-align: center; padding: 6px 12px; background: white; border: 1px solid #6c5ce7; border-radius: 4px;">
						Function<br/>body
					</div>
					<span style="color: #f39c12; font-weight: bold;">x</span>
				</div>
			</div>
		</div>
		<div style="text-align: center; color: #666; font-style: italic; font-size: 15px;">
			"A function that takes x and returns x"
		</div>
	</div>

	<p>In JavaScript, we write this as:</p>

	<pre><code>// Lambda notation: λx.x
const Id = x => x</code></pre>

	<h3>More Examples</h3>

	<pre><code>// Lambda: λx.y
// JavaScript: x => y
// "Take x, return y" (ignores x)

// Lambda: λf.λx.f(x)
// JavaScript: f => x => f(x)
// "Take f, then take x, then apply f to x"</code></pre>

	<h2>Application: Calling Functions</h2>

	<p>Application means "call this function with this argument". We write it by placing terms next to each other:</p>

	<div class="info-box">
		<strong>(λx.x) y</strong><br>
		Apply the function λx.x to the argument y
	</div>

	<p>In JavaScript:</p>

	<pre><code>// Lambda: (λx.x) y
// JavaScript: (x => x)(y)
// Result: y</code></pre>

	<h2>Bound vs Free Variables</h2>

	<p>This is crucial for understanding lambda calculus:</p>

	<ul>
		<li><strong>Bound variable:</strong> A variable that appears after a λ is bound by that λ</li>
		<li><strong>Free variable:</strong> A variable that isn't bound by any λ</li>
	</ul>

	<h3>Examples</h3>

	<pre><code>λx.x
// x is bound (it appears after λx)

λx.y
// x is bound, y is free (no λy to bind it)

λx.λy.x
// Both x and y are bound

λf.f(x)
// f is bound, x is free</code></pre>

	<div class="info-box">
		<strong>Pure functions</strong> (also called combinators) have no free variables. They're self-contained and portable.
	</div>

	<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin: 30px 0;">
		<div style="background: #d4edda; padding: 30px; border-radius: 8px; border: 2px solid #28a745;">
			<h4 style="margin: 0 0 20px 0; color: #155724;">✓ Pure Function</h4>
			<div style="font-family: 'Courier New', monospace; font-size: 18px; margin: 20px 0;">
				λ<span style="background: #c3e6cb; padding: 4px 8px; border-radius: 4px; font-weight: bold;">x</span>.λ<span style="background: #c3e6cb; padding: 4px 8px; border-radius: 4px; font-weight: bold;">y</span>.<span style="background: #c3e6cb; padding: 4px 8px; border-radius: 4px; font-weight: bold;">x</span>
			</div>
			<div style="font-size: 13px; color: #155724; margin-top: 15px;">
				All variables bound<br/>
				✓ Self-contained<br/>
				✓ No external dependencies<br/>
				✓ Portable and testable
			</div>
		</div>

		<div style="background: #f8d7da; padding: 30px; border-radius: 8px; border: 2px solid #dc3545;">
			<h4 style="margin: 0 0 20px 0; color: #721c24;">✗ Impure Function</h4>
			<div style="font-family: 'Courier New', monospace; font-size: 18px; margin: 20px 0;">
				λ<span style="background: #c3e6cb; padding: 4px 8px; border-radius: 4px; font-weight: bold;">x</span>.<span style="background: #c3e6cb; padding: 4px 8px; border-radius: 4px; font-weight: bold;">x</span> × <span style="background: #f5c6cb; padding: 4px 8px; border-radius: 4px; font-weight: bold;">y</span>
			</div>
			<div style="font-size: 13px; color: #721c24; margin-top: 15px;">
				<span style="background: #c3e6cb; padding: 2px 6px; border-radius: 3px; font-weight: bold;">Green</span> = bound, <span style="background: #f5c6cb; padding: 2px 6px; border-radius: 3px; font-weight: bold;">Red</span> = free<br/>
				✗ Depends on external y<br/>
				✗ Not self-contained<br/>
				✗ Harder to reason about
			</div>
		</div>
	</div>

	<h3>Pure Functions in JavaScript</h3>

	<p>If you've done JavaScript development, you've heard about "pure functions." Now you know where the concept comes from! A pure function in JS is one with no free variables - it doesn't access anything outside its scope:</p>

	<pre><code>// Impure - accesses free variable 'taxRate'
let taxRate = 0.1;
const addTax = price => price * (1 + taxRate);  // taxRate is free!

// Pure - no free variables, everything is a parameter
const addTax = taxRate => price => price * (1 + taxRate);</code></pre>

	<p>Why JavaScript developers care about pure functions:</p>

	<ul>
		<li><strong>Testable:</strong> No setup needed, just call with inputs and check outputs</li>
		<li><strong>No race conditions:</strong> Can't change shared state</li>
		<li><strong>Memoizable:</strong> Same inputs always give same output, can cache safely</li>
		<li><strong>Parallelizable:</strong> Safe to run in different threads/workers</li>
		<li><strong>Redux reducers must be pure:</strong> Core requirement of Redux architecture</li>
	</ul>

	<pre><code>// Redux reducer - must be pure!
const counterReducer = (state = 0, action) => {
	switch (action.type) {
		case 'INCREMENT': return state + 1;
		case 'DECREMENT': return state - 1;
		default: return state;
	}
}</code></pre>

	<p>Lambda calculus forces purity - you literally can't write impure functions because there's no concept of external state to access!</p>

	<h2>Referential Transparency</h2>

	<p>Pure functions have a powerful property called <strong>referential transparency</strong>: you can replace any function call with its result without changing the program's behavior. This is the foundation of equational reasoning about code.</p>

	<h3>What is Referential Transparency?</h3>

	<p>An expression is referentially transparent if you can substitute it with its value anywhere in your program and get the same result:</p>

	<pre><code>// Referentially transparent
const add = x => y => x + y;
const result = add(2)(3);  // Always evaluates to 5

// Anywhere you see add(2)(3), you can replace it with 5:
const a = add(2)(3) + 10;   // 15
const b = 5 + 10;            // 15 - same result!

// NOT referentially transparent
let counter = 0;
const increment = () => ++counter;

increment();  // Returns 1
increment();  // Returns 2 - same call, different result!
// Can't replace increment() with a value - result changes each time</code></pre>

	<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin: 30px 0;">
		<div style="background: white; padding: 30px; border-radius: 8px; border: 3px solid #28a745;">
			<h4 style="margin: 0 0 20px 0; color: #155724; display: flex; align-items: center; gap: 10px;">
				<span style="font-size: 24px;">✓</span> Referentially Transparent
			</h4>
			<div style="background: #f8f9fa; padding: 15px; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 13px; margin: 15px 0;">
const add = x => y => x + y;<br/>
const result = add(2)(3);
			</div>
			<div style="background: #d4edda; padding: 20px; border-radius: 4px; border: 2px dashed #28a745; margin-top: 15px;">
				<div style="font-weight: 600; margin-bottom: 10px; color: #155724;">Can substitute with value:</div>
				<div style="font-family: 'Courier New', monospace; font-size: 13px; margin: 8px 0;">
					add(2)(3) + 10 <span style="color: #6c5ce7; font-weight: bold;">=</span> 5 + 10
				</div>
				<div style="font-family: 'Courier New', monospace; font-size: 13px; margin: 8px 0;">
					add(2)(3) * 2 <span style="color: #6c5ce7; font-weight: bold;">=</span> 5 * 2
				</div>
				<div style="font-style: italic; margin-top: 10px; font-size: 12px; color: #155724;">
					Same call always returns same value
				</div>
			</div>
		</div>

		<div style="background: white; padding: 30px; border-radius: 8px; border: 3px solid #dc3545;">
			<h4 style="margin: 0 0 20px 0; color: #721c24; display: flex; align-items: center; gap: 10px;">
				<span style="font-size: 24px;">✗</span> NOT Referentially Transparent
			</h4>
			<div style="background: #f8f9fa; padding: 15px; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 13px; margin: 15px 0;">
let count = 0;<br/>
const inc = () => ++count;
			</div>
			<div style="background: #f8d7da; padding: 20px; border-radius: 4px; border: 2px dashed #dc3545; margin-top: 15px;">
				<div style="font-weight: 600; margin-bottom: 10px; color: #721c24;">Cannot substitute with value:</div>
				<div style="font-family: 'Courier New', monospace; font-size: 13px; margin: 8px 0;">
					inc() <span style="color: #6c5ce7; font-weight: bold;">→</span> 1
				</div>
				<div style="font-family: 'Courier New', monospace; font-size: 13px; margin: 8px 0;">
					inc() <span style="color: #6c5ce7; font-weight: bold;">→</span> 2
				</div>
				<div style="font-style: italic; margin-top: 10px; font-size: 12px; color: #721c24;">
					Same call returns different values!
				</div>
			</div>
		</div>
	</div>

	<h3>Why It Matters in JavaScript</h3>

	<p>Referential transparency enables powerful optimizations and reasoning:</p>

	<pre><code>// React memoization - only works with referentially transparent components
const MemoizedComponent = React.memo(Component);
// React can safely cache: same props = same output, always

// Reselect (Redux) - memoized selectors
const getVisibleTodos = createSelector(
	[getTodos, getFilter],
	(todos, filter) => todos.filter(filter)
);
// Safe to cache because same inputs always give same output

// Safe refactoring - can inline or extract
const price = product.price * 1.2;
// Can replace all uses of 'price' with (product.price * 1.2)

// Parallel execution
const results = await Promise.all([
	fetchUser(1),
	fetchUser(2),
	fetchUser(3)
]);
// Safe because fetchUser(1) always returns the same user

// Compiler optimizations
const x = expensive(5);
const y = expensive(5);
// Compiler can optimize to:
const x = expensive(5);
const y = x;  // Reuse result!</code></pre>

	<h3>Testing Benefits</h3>

	<pre><code>// Referentially transparent = easy to test
test('add function', () => {
	expect(add(2)(3)).toBe(5);
	expect(add(2)(3)).toBe(5);  // Same test, will always pass
});

// NOT referentially transparent = hard to test
test('increment function', () => {
	counter = 0;  // Need to reset state!
	expect(increment()).toBe(1);
	counter = 0;  // Reset again...
	expect(increment()).toBe(1);
});</code></pre>

	<div class="info-box">
		<strong>Referential transparency = pure function + deterministic output</strong><br>
		No side effects, no mutations, same input always gives same output. This is why functional programming emphasizes purity - it makes code predictable and composable.
	</div>

	<h3>Breaking Referential Transparency</h3>

	<p>These common patterns break referential transparency:</p>

	<pre><code>// Reading external state
const getDiscountedPrice = price => price * (1 - globalDiscount);

// Modifying external state
const addToCart = item => { cart.push(item); return cart.length; }

// I/O operations (inherently impure)
const readFile = path => fs.readFileSync(path);  // File might change
const fetchData = url => fetch(url);              // Network might change

// Non-deterministic operations
Math.random()         // Different every time
Date.now()            // Different every time
user.input()          // Depends on user action</code></pre>

	<p>In pure lambda calculus, all expressions are referentially transparent. In JavaScript, we choose when to break this for pragmatic reasons (I/O, randomness), but we isolate these effects to maintain reasoning about most of our code.</p>

	<h2>Beta Reduction: Evaluation</h2>

	<p>Beta reduction is how lambda calculus "runs" - it's the process of applying functions to arguments by substitution.</p>

	<h3>The Rule</h3>

	<div class="info-box">
		<strong>(λx.E) y → E[x := y]</strong><br>
		"Replace every x in E with y"
	</div>

	<p><strong>For JavaScript developers:</strong> Beta reduction is just calling a function! When you write <code>((x) => x + 1)(5)</code>, JavaScript performs beta reduction - it substitutes 5 for x and returns 6. This isn't a metaphor - it's literally the same computational process that lambda calculus describes.</p>

	<pre><code>// This JavaScript code:
((x) => x + 1)(5)

// Performs beta reduction:
// (λx.x + 1) 5
// → [x := 5] in (x + 1)
// → 5 + 1
// → 6</code></pre>

	<div style="padding: 30px 0; margin: 30px 0; overflow-x: auto;">
		<div style="display: flex; align-items: center; justify-content: center; gap: 15px; flex-wrap: wrap;">
			<div style="background: white; padding: 18px 28px; border-radius: 8px; border: 2px solid #6c5ce7; font-family: 'Courier New', monospace; font-size: 18px; white-space: nowrap;">
				(λx.x + 1) 5
			</div>
			<div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
				<div style="font-size: 24px; color: #6c5ce7;">→</div>
				<div style="font-size: 11px; color: #666; font-style: italic; white-space: nowrap;">substitute</div>
			</div>
			<div style="background: white; padding: 18px 28px; border-radius: 8px; border: 2px solid #6c5ce7; font-family: 'Courier New', monospace; font-size: 18px; white-space: nowrap;">
				<span style="background: #fff3cd; padding: 4px 8px; border-radius: 4px;">5</span> + 1
			</div>
			<div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
				<div style="font-size: 24px; color: #6c5ce7;">→</div>
				<div style="font-size: 11px; color: #666; font-style: italic; white-space: nowrap;">evaluate</div>
			</div>
			<div style="background: white; padding: 18px 28px; border-radius: 8px; border: 2px solid #28a745; font-family: 'Courier New', monospace; font-size: 18px; font-weight: bold; white-space: nowrap;">
				6
			</div>
		</div>
	</div>

	<h3>Worked Example 1</h3>

	<div id="demo-beta-1"></div>

	<pre><code>(λx.x) 5
→ 5

Why? Replace x with 5 in the body (which is just x)</code></pre>

	<h3>Worked Example 2</h3>

	<div id="demo-beta-2"></div>

	<pre><code>(λx.λy.x) 3
→ λy.3

Why? Replace x with 3 in the body (λy.x)
Result: λy.3 (a function that ignores its argument and returns 3)</code></pre>

	<h3>Worked Example 3: Multiple Steps</h3>

	<div id="demo-beta-3"></div>

	<pre><code>(λx.λy.x) 3 4
→ (λy.3) 4        [apply first function]
→ 3               [apply second function]

Step 1: (λx.λy.x) 3 becomes λy.3
Step 2: (λy.3) 4 becomes 3</code></pre>

	<h2>Alpha Conversion: Renaming Variables</h2>

	<p>Sometimes we need to rename variables to avoid confusion. This is called alpha conversion, and it doesn't change the meaning of the function.</p>

	<pre><code>λx.x  is the same as  λy.y  is the same as  λz.z

All three mean "the identity function"</code></pre>

	<p>We can rename a bound variable to any other name, as long as we rename it consistently throughout the function body.</p>

	<div class="warning-box">
		<strong>Caution:</strong> Don't rename to a variable that's already in use! <code>λx.λy.x</code> is NOT the same as <code>λy.λy.y</code>
	</div>

	<h2>Parentheses and Precedence</h2>

	<p>Lambda calculus has conventions about when parentheses are needed:</p>

	<h3>Application is Left-Associative</h3>

	<pre><code>f g h  means  (f g) h
// Apply f to g first, then apply the result to h</code></pre>

	<h3>Abstraction Extends as Far Right as Possible</h3>

	<pre><code>λx.x y  means  λx.(x y)
// NOT (λx.x) y

λx.λy.x y  means  λx.(λy.(x y))
// The body of λx is everything after the dot</code></pre>

	<h3>When to Use Parentheses</h3>

	<pre><code>// These need parentheses:
(λx.x) y        // Apply function to y
(λx.x x) (λy.y) // Apply function to another function

// These don't:
λx.x y          // Function body is x y
λx.λy.x         // Nested functions</code></pre>

	<h2>Currying: One Argument at a Time</h2>

	<p>In lambda calculus, all functions take exactly one argument. Multi-argument functions are created by nesting:</p>

	<pre><code>// Want: function that takes x and y, returns x
// Write: λx.λy.x

// This is actually:
λx.(λy.x)
// "A function that takes x and returns (a function that takes y and returns x)"</code></pre>

	<p>In JavaScript:</p>

	<pre><code>// Curried (lambda calculus style)
const K = x => y => x

K(5)(10)        // Returns 5
const always5 = K(5)
always5(10)     // Returns 5</code></pre>

	<div class="info-box">
		This technique is called <strong>currying</strong> (named after Haskell Curry). We'll use it constantly in the coming chapters.
	</div>

	<h2>Interactive Beta Reduction</h2>

	<p>Try reducing some lambda expressions yourself:</p>

	<div id="widget-reduction-explorer"></div>

	<h2>Key Takeaways</h2>

	<ul>
		<li>Lambda calculus has three parts: variables, abstraction (λx.E), and application (f x)</li>
		<li>Bound variables are introduced by λ; free variables come from outside</li>
		<li>Beta reduction is substitution: (λx.E) y → E[x := y]</li>
		<li>Alpha conversion lets us rename bound variables</li>
		<li>Functions take one argument at a time (currying)</li>
		<li>Application is left-associative; abstraction extends right</li>
	</ul>

	<div class="info-box">
		<strong>Next up:</strong> Now that you understand the notation, we'll start building! In Chapter 2, we'll explore combinators - simple but powerful functions that become the building blocks for everything else.
	</div>

	<div class="chapter-nav">
		<a href="../index.html">← Home</a>
		<a href="02-combinators.html">Chapter 2: Combinators →</a>
	</div>

	<script type="module">
		import { InteractiveDemo } from '../js/interactive.js'

		const demo = new InteractiveDemo()

		// Beta reduction demonstrations
		demo.registerDemo('demo-beta-1', () => {
			return `
				<strong>Step-by-step:</strong><br>
				(λx.x) 5<br>
				→ [x := 5] in body (x)<br>
				→ 5
			`
		})

		demo.registerDemo('demo-beta-2', () => {
			return `
				<strong>Step-by-step:</strong><br>
				(λx.λy.x) 3<br>
				→ [x := 3] in body (λy.x)<br>
				→ λy.3
			`
		})

		demo.registerDemo('demo-beta-3', () => {
			return `
				<strong>Step-by-step:</strong><br>
				(λx.λy.x) 3 4<br>
				→ (λy.3) 4<br>
				→ [y := 4] in body (3)<br>
				→ 3
			`
		})

		// Simple interactive widget
		demo.registerWidget('widget-reduction-explorer', {
			inputs: [
				{
					name: 'expression',
					label: 'Try reducing (λx.x) applied to:',
					type: 'text',
					default: 'hello'
				}
			],
			compute: ({ expression }) => {
				// Simple simulation of reduction
				return {
					original: `(λx.x) "${expression}"`,
					reduced: `"${expression}"`,
					explanation: "The identity function returns its argument unchanged"
				}
			}
		})

		demo.runDemos()
		demo.setupWidgets()
	</script>
</body>
</html>
