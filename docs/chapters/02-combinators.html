<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Chapter 2: Combinators (Or: Functions All The Way Down)</title>
	<link rel="stylesheet" href="../css/hybrid-style.css">
</head>
<body>
	<div class="nav">
		<a href="../index.html">Home</a>
		<a href="../index.html#chapters">Chapters</a>
	</div>

	<h1>Chapter 2: Combinators (Or: Functions All The Way Down)</h1>

	<p>Combinators are pure lambda functions with no free variables. They're the atoms from which we'll build more complex functions. In this chapter, we'll explore three fundamental combinators.</p>

	<h2>What is a Pure Function?</h2>

	<p>A <strong>pure function</strong> contains only <em>bound</em> variables. A variable is bound if it appears in the function's parameter list.</p>

	<pre><code>// Pure: all variables are bound
λx.x        // x is bound by λx

// Not pure: y is free (not in parameters)
λx.xy       // x is bound, y is free</code></pre>

	<h2>The Identity Combinator (I)</h2>

	<p>The Identity combinator is the simplest possible function. It takes one argument and returns it unchanged.</p>

	<div class="info-box">
		<strong>Lambda notation:</strong> λx.x<br>
		<strong>JavaScript:</strong> <code>x => x</code>
	</div>

	<pre><code>const Id = x => x</code></pre>

	<p>The Identity function might seem useless, but it's a crucial building block. It represents the concept of "doing nothing" or "returning unchanged."</p>

	<h3>Examples</h3>

	<div id="demo-id-number"></div>
	<div id="demo-id-string"></div>
	<div id="demo-id-function"></div>

	<h3>Identity in the Wild</h3>

	<p>You use the Identity function constantly in JavaScript, often without realizing it:</p>

	<pre><code>// Array operations
[1, 2, 3].map(x => x)           // Copy array with map
[...array]                       // Spread is like Id for arrays

// Functional programming
Promise.resolve(value)           // Wrap value in promise (unchanged)
Observable.of(value)             // RxJS - wrap in observable

// Default values
const identity = x => x;
const transform = fn || identity; // If no fn, just return unchanged

// React
const Component = ({ children = x => x }) => children();

// Lodash/Ramda
_.identity(value)                // Explicit identity function</code></pre>

	<p>The Identity pattern is everywhere because it represents "no transformation" - the base case for many operations.</p>

	<h2>The Constant Combinator (K)</h2>

	<p>The Constant combinator creates a function that always returns its first argument, ignoring the second.</p>

	<div class="info-box">
		<strong>Lambda notation:</strong> λx.λy.x<br>
		<strong>JavaScript:</strong> <code>x => y => x</code>
	</div>

	<pre><code>const K = x => y => x</code></pre>

	<p>K is a <em>curried</em> function that takes two arguments. It returns a function that "remembers" the first argument and ignores whatever you pass it next.</p>

	<h3>Examples</h3>

	<div id="demo-k-basic"></div>
	<div id="demo-k-partial"></div>

	<h3>Constant in JavaScript</h3>

	<p>The Constant pattern appears everywhere in JavaScript - any time you ignore an argument:</p>

	<pre><code>// Event handlers (ignore the event object)
button.addEventListener('click', () => console.log('clicked'));
button.addEventListener('click', () => setCount(0));

// Array transformations (ignore each element, return constant)
[1, 2, 3].map(() => 0)           // Replace all with 0
[1, 2, 3].map(() => 'same')      // Replace all with 'same'

// Timers (ignore the timer ID)
setTimeout(() => doThing(), 1000);

// React event handlers
<button onClick={() => setCount(0)}>  {/* Ignores event */}
<input onChange={() => setOpen(false)}>  {/* Ignores event */}

// Default fallbacks
const value = userInput || DEFAULT;  // If falsy, use constant
const name = user?.name ?? 'Guest';  // Nullish coalescing</code></pre>

	<p>Every time you use <code>() => value</code> in JavaScript, you're using the Constant combinator pattern!</p>

	<h3>Understanding Currying in Depth</h3>

	<p>K is our first real encounter with currying. Let's break down exactly what's happening:</p>

	<pre><code>const K = x => y => x

// This is shorthand for:
const K = x => {
  return y => {
    return x
  }
}</code></pre>

	<p>When you call <code>K</code>, here's the step-by-step process:</p>

	<ol>
		<li>Call <code>K(5)</code> - the outer function receives 5 and binds it to x</li>
		<li>Returns a new function: <code>y => 5</code></li>
		<li>That returned function ignores y and always returns 5</li>
	</ol>

	<pre><code>const alwaysFive = K(5)  // Returns: y => 5

alwaysFive(1)      // Returns: 5
alwaysFive(100)    // Returns: 5
alwaysFive("hi")   // Returns: 5</code></pre>

	<div id="demo-k-currying"></div>

	<h3>Currying vs Uncurried Functions</h3>

	<p>Compare these two versions of the same function:</p>

	<pre><code>// Uncurried (traditional JavaScript)
const constantUncurried = (x, y) => x

constantUncurried(5, 10)  // Returns: 5

// Curried (lambda calculus style)
const K = x => y => x

K(5)(10)                  // Returns: 5
const always5 = K(5)
always5(10)               // Returns: 5 (partial application!)</code></pre>

	<p>The curried version is more flexible - you can "partially apply" it by calling it with just one argument.</p>

	<h3>Partial Application in Action</h3>

	<p>Currying enables powerful patterns through partial application:</p>

	<pre><code>// Create specialized functions from K
const alwaysTrue = K(true)
const alwaysFalse = K(false)
const alwaysZero = K(0)

alwaysTrue("anything")   // true
alwaysFalse(42)          // false
alwaysZero([1, 2, 3])    // 0</code></pre>

	<p>This pattern - creating specific functions from general ones - is fundamental to functional programming.</p>

	<div class="info-box">
		<strong>Why "currying"?</strong> Named after logician Haskell Curry (who also has a programming language named after him). Though actually invented by Moses Schönfinkel!
	</div>

	<h3>Currying in Production JavaScript</h3>

	<p>Currying is used extensively in modern JavaScript libraries and frameworks:</p>

	<pre><code>// Redux action creators
const updateUser = userId => updates => ({
	type: 'UPDATE_USER',
	payload: { userId, updates }
});

const updateUser1 = updateUser(1);
updateUser1({ name: 'Alice' });  // Specialized for user 1

// Ramda/Lodash FP - all functions are curried
const add = R.curry((a, b) => a + b);
const add5 = add(5);
[1, 2, 3].map(add5);  // [6, 7, 8]

// React hooks return curried functions
const [count, setCount] = useState(0);
// setCount is like K - ignores previous value if you pass a value
// onClick={() => setCount(0)} is the K pattern!

// Logging with levels
const log = level => message => console[level](message);
const error = log('error');
const warn = log('warn');
error('Something went wrong!');  // console.error('Something went wrong!')

// API calls with base configuration
const api = baseUrl => endpoint => data =>
	fetch(`${baseUrl}${endpoint}`, {
		method: 'POST',
		body: JSON.stringify(data)
	});

const myApi = api('https://api.example.com');
const usersApi = myApi('/users');
usersApi({ name: 'Bob' });  // POST to https://api.example.com/users</code></pre>

	<p>Currying lets you create specialized functions from general ones - it's configuration through partial application!</p>

	<h2>The Self-Application Combinator (M)</h2>

	<p>The M combinator (also called Mockingbird) applies a function to itself. This is where lambda calculus starts to get interesting!</p>

	<div class="info-box">
		<strong>Lambda notation:</strong> λf.f f<br>
		<strong>JavaScript:</strong> <code>f => f(f)</code>
	</div>

	<pre><code>const M = f => f(f)</code></pre>

	<p>M takes a function and applies it to itself. This might seem strange, but it's powerful.</p>

	<h3>Example with Identity</h3>

	<div id="demo-m-identity"></div>

	<div class="warning-box">
		<strong>Warning:</strong> Be careful with M! Some applications cause infinite loops:
		<pre><code>M(M)  // Applies M to M, which applies M to M, which...</code></pre>
		This is called the Omega combinator and will crash JavaScript!
	</div>

	<h2>Why Combinators Matter</h2>

	<p>These simple combinators are building blocks for everything in lambda calculus:</p>

	<ul>
		<li><strong>Id</strong> represents identity and will be used for extracting values</li>
		<li><strong>K</strong> represents choice and selection (you'll see this in booleans!)</li>
		<li><strong>M</strong> represents self-reference and is key to recursion</li>
	</ul>

	<h2>Interactive Explorer</h2>

	<p>Try applying combinators yourself:</p>

	<div id="widget-combinator-explorer"></div>

	<div class="exercise-box">
		<h3>Exercises</h3>
		<ol>
			<li>What does <code>Id(Id)</code> return?</li>
			<li>What does <code>K(K)(Id)</code> return?</li>
			<li>Can you explain why <code>M(Id)</code> returns Id?</li>
			<li>What is the difference between <code>Id</code> and <code>K(x)</code>?</li>
		</ol>
	</div>

	<h2>Key Takeaways</h2>

	<ul>
		<li>Combinators are pure functions with no free variables</li>
		<li>Id returns its argument unchanged - the simplest combinator</li>
		<li>K creates constant functions through currying: <code>K(x)(y) = x</code></li>
		<li>Currying means taking arguments one at a time, enabling partial application</li>
		<li>M applies a function to itself - important for recursion later</li>
		<li>These simple building blocks enable complex computation</li>
	</ul>

	<div class="chapter-nav">
		<a href="01-lambda-notation.html">← Chapter 1: Lambda Notation</a>
		<a href="03-church-encodings.html">Chapter 3: Church Encodings →</a>
	</div>

	<script type="module">
		import { Id, K, M } from '../lib/combinators.js'
		import { InteractiveDemo } from '../js/interactive.js'

		const demo = new InteractiveDemo()

		// Register demos
		demo.registerDemo('demo-id-number', () => {
			return `Id(42) = ${Id(42)}`
		})

		demo.registerDemo('demo-id-string', () => {
			return `Id("hello") = "${Id("hello")}"`
		})

		demo.registerDemo('demo-id-function', () => {
			const result = Id(Id)
			return `Id(Id) = ${result === Id ? 'Id (itself!)' : 'unexpected'}`
		})

		demo.registerDemo('demo-k-basic', () => {
			return `K(5)(10) = ${K(5)(10)}`
		})

		demo.registerDemo('demo-k-partial', () => {
			return `K("first")("second") = "${K("first")("second")}"`
		})

		demo.registerDemo('demo-k-currying', () => {
			const alwaysFive = K(5)
			return `
				const alwaysFive = K(5)<br>
				alwaysFive(1) = ${alwaysFive(1)}<br>
				alwaysFive(100) = ${alwaysFive(100)}<br>
				alwaysFive("hi") = ${alwaysFive("hi")}
			`
		})

		demo.registerDemo('demo-m-identity', () => {
			const result = M(Id)
			return `M(Id) = ${result === Id ? 'Id (because Id(Id) returns Id)' : result}`
		})

		// Interactive widget
		demo.registerWidget('widget-combinator-explorer', {
			inputs: [
				{ name: 'value', label: 'Test Value', type: 'number', default: 7, min: 0, max: 100 }
			],
			compute: ({ value }) => {
				return {
					id: Id(value),
					k_value_10: K(value)(10),
					k_10_value: K(10)(value)
				}
			}
		})

		demo.runDemos()
		demo.setupWidgets()
	</script>
</body>
</html>
