<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Chapter 5: Data Structures (Or: How to Stack Turtles)</title>
	<link rel="stylesheet" href="../css/hybrid-style.css">
</head>
<body>
	<div class="nav">
		<a href="../index.html">Home</a>
		<a href="../index.html#chapters">Chapters</a>
	</div>

	<h1>Chapter 5: Data Structures (Or: How to Stack Turtles)</h1>

	<p>We've seen how to represent booleans and numbers as functions. Now we'll build complex data structures - specifically lists - using only functions. This demonstrates that lambda calculus is Turing-complete!</p>

	<h2>Review: Pairs</h2>

	<p>From Chapter 2, recall that Pairs store two values:</p>

	<pre><code>const Pair = a => b => f => f(a)(b)

const First = p => p(True)
const Second = p => p(False)</code></pre>

	<p>Pairs are the foundation for building lists and more complex structures.</p>

	<div id="demo-pair-review"></div>

	<h3>Pairs in JavaScript</h3>

	<p>Pairs are everywhere in JavaScript - you use them constantly without thinking about it:</p>

	<pre><code>// Array destructuring (pairs!)
const [first, second] = [1, 2];
const [head, ...tail] = array;

// React useState returns a pair!
const [count, setCount] = useState(0);
// First: the value
// Second: the setter function

// Objects as pairs
const point = { x: 10, y: 20 };  // Pair of coordinates
const { x, y } = point;

// Map/WeakMap entries
map.set(key, value);  // Stores pairs
for (let [key, value] of map) { ... }

// Node.js callback pattern
callback(error, data);  // Pair: error or result

// Function returning multiple values
function divMod(a, b) {
	return [Math.floor(a / b), a % b];  // Pair of results
}
const [quotient, remainder] = divMod(17, 5);</code></pre>

	<p>Pairs are the simplest compound data structure - they let you group exactly two related values together.</p>

	<h2>Lists as Nested Pairs</h2>

	<p>A list is built from nested pairs. Each pair contains:</p>

	<ul>
		<li><strong>First:</strong> The current element (head)</li>
		<li><strong>Second:</strong> The rest of the list (tail)</li>
	</ul>

	<p>An empty list is represented by a special Nil value:</p>

	<pre><code>const Nil = Pair(False)(False)</code></pre>

	<h3>Visual Representation</h3>

	<div class="info-box">
		<strong>Empty list:</strong> Nil<br>
		<strong>List [1]:</strong> Pair(1)(Nil)<br>
		<strong>List [1, 2]:</strong> Pair(1)(Pair(2)(Nil))<br>
		<strong>List [1, 2, 3]:</strong> Pair(1)(Pair(2)(Pair(3)(Nil)))
	</div>

	<div style="padding: 30px 0; margin: 30px 0;">
		<div style="text-align: center; margin-bottom: 25px; font-size: 14px; color: #666; font-weight: 600;">
			List [1, 2, 3] as Nested Pairs
		</div>
		<div style="max-width: 900px; margin: 0 auto; background: white; padding: 40px; border-radius: 8px; border: 2px solid #6c5ce7;">
			<div style="display: flex; align-items: center; justify-content: center; gap: 20px; flex-wrap: wrap;">
				<!-- First Pair -->
				<div style="background: #e8f4f8; padding: 20px; border-radius: 8px; border: 2px solid #17a2b8; position: relative;">
					<div style="position: absolute; top: -12px; left: 10px; background: white; padding: 0 8px; font-size: 11px; color: #17a2b8; font-weight: bold;">
						Pair
					</div>
					<div style="display: flex; gap: 15px;">
						<div style="background: #d4edda; padding: 15px 20px; border-radius: 6px; border: 2px solid #28a745; text-align: center;">
							<div style="font-size: 11px; color: #155724; margin-bottom: 5px;">head</div>
							<div style="font-size: 20px; font-weight: bold; color: #28a745;">1</div>
						</div>
						<div style="font-size: 24px; align-self: center; color: #666;">→</div>
						<!-- Second Pair -->
						<div style="background: #e8f4f8; padding: 20px; border-radius: 8px; border: 2px solid #17a2b8; position: relative;">
							<div style="position: absolute; top: -12px; left: 10px; background: white; padding: 0 8px; font-size: 11px; color: #17a2b8; font-weight: bold;">
								Pair
							</div>
							<div style="display: flex; gap: 15px;">
								<div style="background: #d4edda; padding: 15px 20px; border-radius: 6px; border: 2px solid #28a745; text-align: center;">
									<div style="font-size: 11px; color: #155724; margin-bottom: 5px;">head</div>
									<div style="font-size: 20px; font-weight: bold; color: #28a745;">2</div>
								</div>
								<div style="font-size: 24px; align-self: center; color: #666;">→</div>
								<!-- Third Pair -->
								<div style="background: #e8f4f8; padding: 20px; border-radius: 8px; border: 2px solid #17a2b8; position: relative;">
									<div style="position: absolute; top: -12px; left: 10px; background: white; padding: 0 8px; font-size: 11px; color: #17a2b8; font-weight: bold;">
										Pair
									</div>
									<div style="display: flex; gap: 15px;">
										<div style="background: #d4edda; padding: 15px 20px; border-radius: 6px; border: 2px solid #28a745; text-align: center;">
											<div style="font-size: 11px; color: #155724; margin-bottom: 5px;">head</div>
											<div style="font-size: 20px; font-weight: bold; color: #28a745;">3</div>
										</div>
										<div style="font-size: 24px; align-self: center; color: #666;">→</div>
										<div style="background: #f8d7da; padding: 15px 20px; border-radius: 6px; border: 2px solid #dc3545; text-align: center;">
											<div style="font-size: 11px; color: #721c24; margin-bottom: 5px;">tail</div>
											<div style="font-size: 14px; font-weight: bold; color: #dc3545; font-family: 'Courier New', monospace;">Nil</div>
										</div>
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
			</div>
			<div style="text-align: center; margin-top: 30px; font-size: 13px; color: #666; font-style: italic;">
				Each pair contains: (1) the current element and (2) the rest of the list
			</div>
		</div>
	</div>

	<h2>The Cons Function</h2>

	<p><strong>Cons</strong> (short for "construct") prepends an element to the front of a list. This is the standard name in functional programming, originating from Lisp:</p>

	<pre><code>const Cons = head => list => f => x => f(head)(list(f)(x))</code></pre>

	<p>This creates a new list with the head element followed by the existing list.</p>

	<div id="demo-append"></div>

	<h3>Building a List</h3>

	<pre><code>const list1 = Cons(One)(Nil)           // [1]
const list2 = Cons(Two)(list1)          // [2, 1]
const list3 = Cons(Three)(list2)        // [3, 2, 1]</code></pre>

	<div id="demo-build-list"></div>

	<h3>Functional Lists vs JavaScript Arrays</h3>

	<p>Lambda calculus lists are "linked lists" - very different from JavaScript arrays. But the patterns are familiar:</p>

	<pre><code>// JavaScript array destructuring
const [head, ...tail] = [1, 2, 3, 4];
// head = 1
// tail = [2, 3, 4]

// This IS the lambda calculus list pattern!
// First(list) = head
// Second(list) = tail

// Immutable list operations (React/Redux style)
const newArray = [newItem, ...oldArray];  // Prepend (like Cons!)
const [first, ...rest] = array;           // Head/tail split

// Recursive array processing (functional style)
function sum(arr) {
	if (arr.length === 0) return 0;
	const [head, ...tail] = arr;
	return head + sum(tail);  // Head + recursive call on tail
}

// This is exactly how lambda calculus lists work!</code></pre>

	<p>The key difference: JavaScript arrays have random access (fast <code>array[5]</code>), while lambda lists must traverse from the start. But the head/tail pattern is identical!</p>

	<div class="info-box">
		<strong>Immutability matters:</strong> In React and Redux, you never mutate arrays - you always create new ones. This is the lambda calculus philosophy! Lists are immutable by nature.
	</div>

	<h2>List Operations</h2>

	<h3>Head - Get First Element</h3>

	<pre><code>const Head = list => list(a => b => a)(Id)</code></pre>

	<p>Head extracts the first element from a list.</p>

	<div id="demo-head"></div>

	<h3>Tail - Get Rest of List</h3>

	<pre><code>const Tail = list => First(
	list(
		a => b => Pair(Second(b))(Cons(a)(Second(b)))
	)(Nil)
)</code></pre>

	<p>Tail returns everything except the first element. This is complex because we need to "shift" through the list.</p>

	<div id="demo-tail"></div>

	<h3>isEmpty - Check if List is Empty</h3>

	<pre><code>const isEmpty = list => list(a => b => False)(True)</code></pre>

	<p>Returns True if the list is Nil, False otherwise.</p>

	<div id="demo-isempty"></div>

	<h2>Interactive List Builder</h2>

	<p>Build and explore lists interactively:</p>

	<div id="widget-list-builder"></div>

	<h2>Visual List Structure</h2>

	<p>Here's how a list [1, 2, 3] looks as nested pairs:</p>

	<div id="visualize-list"></div>

	<h2>Traversing Lists</h2>

	<p>To process a list, we can recursively apply operations:</p>

	<pre><code>// Pseudocode for list traversal
function processList(list) {
	if (isEmpty(list)) {
		return baseCase
	} else {
		const h = Head(list)
		const t = Tail(list)
		return combine(h, processList(t))
	}
}</code></pre>

	<p>This pattern is fundamental to functional programming!</p>

	<div class="exercise-box">
		<h3>Exercises</h3>
		<ol>
			<li>Create a list [4, 5, 6] using Cons and Nil</li>
			<li>What is Head(Tail([1, 2, 3]))?</li>
			<li>What is isEmpty(Nil)?</li>
			<li>What happens when you call Head(Nil)?</li>
			<li>Can you think of how to implement a Length function?</li>
		</ol>
	</div>

	<h2>Why This Matters</h2>

	<p>Lists are fundamental data structures in programming. By encoding them as functions, we've shown that:</p>

	<ul>
		<li>Complex structures can be built from simple abstractions</li>
		<li>Functions can represent any data type</li>
		<li>Lambda calculus can express real-world programs</li>
		<li>The divide between "code" and "data" is artificial</li>
	</ul>

	<h2>Key Takeaways</h2>

	<ul>
		<li>Lists are nested pairs terminating in Nil</li>
		<li>Cons adds an element to the front of a list</li>
		<li>Head extracts the first element</li>
		<li>Tail returns the rest of the list</li>
		<li>isEmpty checks if a list is empty</li>
		<li>All data structures can be encoded as functions</li>
	</ul>

	<div class="chapter-nav">
		<a href="04-numerals.html">← Chapter 4: Church Numerals</a>
		<a href="06-recursion.html">Chapter 6: Recursion →</a>
	</div>

	<script type="module">
		import { Pair, First, Second, One, Two, Three, Four, Five, True, False } from '../lib/lamb.js'
		import { Cons, Head, Tail, isEmpty, Nil } from '../lib/data.js'
		import { toInt, toBoolean, toArray } from '../lib/utils.js'
		import { InteractiveDemo } from '../js/interactive.js'
		import { ListVisualizer } from '../js/visualizer.js'

		const demo = new InteractiveDemo()

		// Pair review
		demo.registerDemo('demo-pair-review', () => {
			const pair = Pair(10)(20)
			return `
				const pair = Pair(10)(20)<br>
				First(pair) = ${First(pair)}<br>
				Second(pair) = ${Second(pair)}
			`
		})

		// Cons demo
		demo.registerDemo('demo-append', () => {
			const list1 = Cons(One)(Nil)
			const list2 = Cons(Two)(list1)
			return `
				const list1 = Cons(One)(Nil)<br>
				toArray(list1) = [${toArray(list1)}]<br>
				<br>
				const list2 = Cons(Two)(list1)<br>
				toArray(list2) = [${toArray(list2)}]
			`
		})

		// Build list demo
		demo.registerDemo('demo-build-list', () => {
			const list = Cons(Three)(Cons(Two)(Cons(One)(Nil)))
			return `
				Cons(Three)(Cons(Two)(Cons(One)(Nil)))<br>
				Result: [${toArray(list)}]
			`
		})

		// Head demo
		demo.registerDemo('demo-head', () => {
			const list = Cons(Five)(Cons(Four)(Cons(Three)(Nil)))
			const h = Head(list)
			return `
				const list = [${toArray(list)}]<br>
				Head(list) = ${toInt(h)}
			`
		})

		// Tail demo
		demo.registerDemo('demo-tail', () => {
			const list = Cons(Five)(Cons(Four)(Cons(Three)(Nil)))
			const t = Tail(list)
			return `
				const list = [${toArray(list)}]<br>
				Tail(list) = [${toArray(t)}]
			`
		})

		// isEmpty demo
		demo.registerDemo('demo-isempty', () => {
			const list = Cons(One)(Nil)
			return `
				isEmpty(Nil) = ${toBoolean(isEmpty(Nil))}<br>
				isEmpty([${toArray(list)}]) = ${toBoolean(isEmpty(list))}
			`
		})

		// List visualization
		demo.registerDemo('visualize-list', () => {
			const arr = [1, 2, 3]
			return ListVisualizer.visualizePairs(arr)
		})

		// Interactive widget
		demo.registerWidget('widget-list-builder', {
			inputs: [
				{ name: 'a', label: 'Element 1', type: 'number', default: 1, min: 0, max: 10 },
				{ name: 'b', label: 'Element 2', type: 'number', default: 2, min: 0, max: 10 },
				{ name: 'c', label: 'Element 3', type: 'number', default: 3, min: 0, max: 10 }
			],
			compute: ({ a, b, c }) => {
				// Build list from user inputs (Cons prepends)
				const list = Cons(a)(Cons(b)(Cons(c)(Nil)))

				return {
					'List': `[${a}, ${b}, ${c}]`,
					'As nested pairs': `Pair(${a})(Pair(${b})(Pair(${c})(Nil)))`,
					'Head (First)': First(list),
					'Tail (Rest)': `[${b}, ${c}]`,
					'isEmpty': 'false'
				}
			}
		})

		demo.runDemos()
		demo.setupWidgets()
	</script>
</body>
</html>
