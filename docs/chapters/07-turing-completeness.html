<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Chapter 7: Turing Completeness (Or: Artium Obscura Functionis*)</title>
	<link rel="stylesheet" href="../css/hybrid-style.css">
</head>
<body>
	<div class="nav">
		<a href="../index.html">Home</a>
		<a href="../index.html#chapters">Chapters</a>
	</div>

	<h1>Chapter 7: Turing Completeness (Or: Artium Obscura Functionis*)</h1>

	<p>You've built an entire computational system from nothing but functions. Now we'll prove something remarkable: lambda calculus is <strong>Turing complete</strong>, meaning it can compute anything that any computer can compute.</p>

	<h2>What is Turing Completeness?</h2>

	<p>A system is Turing complete if it can simulate a Turing machine - the theoretical model of computation proposed by Alan Turing in 1936. In practical terms, this means the system can compute anything that's computable.</p>

	<h3>Requirements for Turing Completeness</h3>

	<p>To be Turing complete, a system needs:</p>

	<ol>
		<li><strong>Data storage:</strong> Ability to store and retrieve arbitrary amounts of data</li>
		<li><strong>Conditional logic:</strong> Ability to make decisions (if/then/else)</li>
		<li><strong>Repetition:</strong> Ability to repeat operations (loops or recursion)</li>
		<li><strong>Arbitrary computation:</strong> Ability to perform any sequence of operations</li>
	</ol>

	<p>Surprisingly simple systems can be Turing complete - even a carefully designed set of dominos could theoretically compute anything!</p>

	<h2>Lambda Calculus is Turing Complete</h2>

	<p>Let's prove lambda calculus meets all the requirements. We've already built everything we need!</p>

	<div style="padding: 30px 0; margin: 30px 0;">
		<div style="text-align: center; margin-bottom: 30px; font-size: 16px; color: #666; font-weight: 600;">
			Lambda Calculus: Turing Complete ✓
		</div>
		<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 25px; max-width: 900px; margin: 0 auto;">
			<!-- Data Storage -->
			<div style="background: white; padding: 30px; border-radius: 8px; border: 2px solid #28a745;">
				<div style="display: flex; align-items: center; gap: 15px; margin-bottom: 20px;">
					<div style="font-size: 32px; color: #28a745;">✓</div>
					<div style="font-size: 18px; font-weight: bold; color: #155724;">Data Storage</div>
				</div>
				<div style="background: #d4edda; padding: 15px; border-radius: 6px; margin-bottom: 15px;">
					<div style="font-family: 'Courier New', monospace; font-size: 13px; margin: 5px 0;">• Booleans (True/False)</div>
					<div style="font-family: 'Courier New', monospace; font-size: 13px; margin: 5px 0;">• Numbers (Church numerals)</div>
					<div style="font-family: 'Courier New', monospace; font-size: 13px; margin: 5px 0;">• Pairs (grouping)</div>
					<div style="font-family: 'Courier New', monospace; font-size: 13px; margin: 5px 0;">• Lists (sequences)</div>
				</div>
				<div style="font-size: 12px; color: #666; font-style: italic;">All data represented as functions</div>
			</div>

			<!-- Conditional Logic -->
			<div style="background: white; padding: 30px; border-radius: 8px; border: 2px solid #28a745;">
				<div style="display: flex; align-items: center; gap: 15px; margin-bottom: 20px;">
					<div style="font-size: 32px; color: #28a745;">✓</div>
					<div style="font-size: 18px; font-weight: bold; color: #155724;">Conditional Logic</div>
				</div>
				<div style="background: #d4edda; padding: 15px; border-radius: 6px; margin-bottom: 15px;">
					<div style="font-family: 'Courier New', monospace; font-size: 13px; margin: 5px 0;">• If/Then/Else</div>
					<div style="font-family: 'Courier New', monospace; font-size: 13px; margin: 5px 0;">• And/Or/Not gates</div>
					<div style="font-family: 'Courier New', monospace; font-size: 13px; margin: 5px 0;">• Comparison (isZero, EQ, LEQ)</div>
				</div>
				<div style="font-size: 12px; color: #666; font-style: italic;">Decision-making through selection</div>
			</div>

			<!-- Repetition -->
			<div style="background: white; padding: 30px; border-radius: 8px; border: 2px solid #28a745;">
				<div style="display: flex; align-items: center; gap: 15px; margin-bottom: 20px;">
					<div style="font-size: 32px; color: #28a745;">✓</div>
					<div style="font-size: 18px; font-weight: bold; color: #155724;">Repetition</div>
				</div>
				<div style="background: #d4edda; padding: 15px; border-radius: 6px; margin-bottom: 15px;">
					<div style="font-family: 'Courier New', monospace; font-size: 13px; margin: 5px 0;">• Recursion (Factorial, Fibonacci)</div>
					<div style="font-family: 'Courier New', monospace; font-size: 13px; margin: 5px 0;">• Thunking (lazy evaluation)</div>
					<div style="font-family: 'Courier New', monospace; font-size: 13px; margin: 5px 0;">• Y combinator (self-reference)</div>
				</div>
				<div style="font-size: 12px; color: #666; font-style: italic;">Loops via recursive functions</div>
			</div>

			<!-- Arbitrary Computation -->
			<div style="background: white; padding: 30px; border-radius: 8px; border: 2px solid #28a745;">
				<div style="display: flex; align-items: center; gap: 15px; margin-bottom: 20px;">
					<div style="font-size: 32px; color: #28a745;">✓</div>
					<div style="font-size: 18px; font-weight: bold; color: #155724;">Arbitrary Computation</div>
				</div>
				<div style="background: #d4edda; padding: 15px; border-radius: 6px; margin-bottom: 15px;">
					<div style="font-family: 'Courier New', monospace; font-size: 13px; margin: 5px 0;">• Composition (combine functions)</div>
					<div style="font-family: 'Courier New', monospace; font-size: 13px; margin: 5px 0;">• Arithmetic (Add, Multiply, etc.)</div>
					<div style="font-family: 'Courier New', monospace; font-size: 13px; margin: 5px 0;">• Algorithms (any computable function)</div>
				</div>
				<div style="font-size: 12px; color: #666; font-style: italic;">Compute anything computable</div>
			</div>
		</div>
		<div style="text-align: center; margin-top: 30px; padding: 20px; background: #d4edda; border-radius: 8px; max-width: 700px; margin-left: auto; margin-right: auto; border: 2px solid #28a745;">
			<div style="font-size: 18px; font-weight: bold; color: #155724; margin-bottom: 10px;">
				Result: Lambda Calculus = Universal Computer
			</div>
			<div style="font-size: 14px; color: #666;">
				Can compute anything that any programming language or computer can compute
			</div>
		</div>
	</div>

	<h2>The Y-Combinator: Recursion Without Names</h2>

	<p>In Chapter 6, we used JavaScript's ability to reference functions by name. But pure lambda calculus has <em>no names</em> - only anonymous functions. How can a function call itself if it can't reference itself?</p>

	<h3>The Problem</h3>

	<p>Consider factorial. In JavaScript we write:</p>

	<pre><code>function factorial(n) {
	return n === 0 ? 1 : n * factorial(n - 1)
}  // ✓ Works - "factorial" is in scope</code></pre>

	<p>But in pure lambda calculus, we only have anonymous functions:</p>

	<pre><code>λn. if (n = 0) then 1 else n × ???(n - 1)
                              ↑
                     Can't reference myself!</code></pre>

	<p>The function has no name to call. This is the fundamental problem the Y-combinator solves.</p>

	<h3>The Solution: Fixed Points</h3>

	<p>A <strong>fixed point</strong> of a function f is a value x where f(x) = x. For example, 0 is a fixed point of f(x) = x², because 0² = 0.</p>

	<p>The Y-combinator finds <em>fixed points of functions that return functions</em>. For any function f:</p>

	<div style="text-align: center; font-size: 1.3em; padding: 20px; background: #f0f7ff; border-radius: 8px; margin: 20px 0; border: 2px solid #2196F3;">
		<strong>Y f = f (Y f)</strong>
	</div>

	<p>This is exactly what we need for recursion! If we define factorial-maker as a function that takes "itself" as an argument:</p>

	<pre><code>// factorial-maker takes a "recursive-call" function
const factorialMaker = recurse => n =>
	n === 0 ? 1 : n * recurse(n - 1)

// Y gives us the fixed point - a working factorial!
const factorial = Y(factorialMaker)</code></pre>

	<h3>The Definition</h3>

	<p>The Y-combinator in pure lambda calculus:</p>

	<div style="text-align: center; font-size: 1.2em; padding: 20px; background: #fff3e0; border-radius: 8px; margin: 20px 0; border: 2px solid #ff9800; font-family: 'Courier New', monospace;">
		Y = λf.(λx.f(x x))(λx.f(x x))
	</div>

	<p>In JavaScript (with a lazy twist for strict evaluation):</p>

	<pre><code>// Lazy Y-combinator (works in JavaScript's eager evaluation)
const Y = f => (x => f(v => x(x)(v)))(x => f(v => x(x)(v)))</code></pre>

	<p>The <code>v => x(x)(v)</code> wrapper delays the self-application, preventing infinite loops in JavaScript's strict evaluation.</p>

	<h3>Step-by-Step: How Y Works</h3>

	<div id="demo-y-combinator-reduction"></div>

	<h3>Y-Combinator Factorial</h3>

	<p>Let's see the Y-combinator compute factorial:</p>

	<div id="demo-y-factorial"></div>

	<h3>Try It: Y-Combinator Calculator</h3>

	<p>Explore different recursive functions - all built using the same Y-combinator!</p>

	<div class="info-box">
		<strong>Available functions:</strong> factorial, sum, fibonacci, countdown<br>
		<strong>Stack limit:</strong> Values above 12 may overflow (fibonacci limited to 10).
	</div>

	<div id="widget-y-combinator"></div>

	<h3>Comparison: Named vs Y-Combinator Recursion</h3>

	<table>
		<tr>
			<th>Aspect</th>
			<th>Named Recursion</th>
			<th>Y-Combinator</th>
		</tr>
		<tr>
			<td>Self-reference</td>
			<td>Uses function name</td>
			<td>Anonymous - no names needed</td>
		</tr>
		<tr>
			<td>Language support</td>
			<td>Requires named functions</td>
			<td>Works in pure lambda calculus</td>
		</tr>
		<tr>
			<td>Flexibility</td>
			<td>Fixed behavior</td>
			<td>Can be wrapped/modified</td>
		</tr>
		<tr>
			<td>Debugging</td>
			<td>Clear stack traces</td>
			<td>Complex stack traces</td>
		</tr>
		<tr>
			<td>Use in practice</td>
			<td>Always (when available)</td>
			<td>Theoretical interest, some FP patterns</td>
		</tr>
	</table>

	<div class="info-box">
		<strong>Why does Y matter?</strong> The Y-combinator proves that recursion is derivable from first principles. We don't need special language support - anonymous functions alone are enough for any recursive computation.
	</div>

	<h2>The Halting Problem</h2>

	<p>With Turing completeness comes an uncomfortable truth: some questions about programs are <em>fundamentally unanswerable</em>.</p>

	<h3>The Question</h3>

	<p>Can we build a program <code>halts(program, input)</code> that tells us whether any given program will eventually finish or run forever?</p>

	<pre><code>function halts(program, input) {
	// Analyze the program...
	// Return true if it halts, false if infinite loop
	return ???  // Is this possible?
}</code></pre>

	<p>This would be incredibly useful! We could detect infinite loops before running code.</p>

	<h3>The Proof: It's Impossible</h3>

	<p>Alan Turing proved in 1936 that no such program can exist. Here's the clever contradiction:</p>

	<div style="background: #fff8e1; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #ffc107;">
		<p><strong>Step 1:</strong> Assume <code>halts(program, input)</code> exists.</p>
		<p><strong>Step 2:</strong> Build a paradoxical program:</p>
		<pre><code>function paradox(program) {
	if (halts(program, program)) {
		while (true) {}  // Loop forever if it "halts"
	}
	return  // Halt if it "loops forever"
}</code></pre>
		<p><strong>Step 3:</strong> Run <code>paradox(paradox)</code>:</p>
		<ul>
			<li>If <code>halts</code> says it halts → it loops forever (contradiction!)</li>
			<li>If <code>halts</code> says it loops → it halts (contradiction!)</li>
		</ul>
		<p><strong>Conclusion:</strong> <code>halts</code> cannot exist.</p>
	</div>

	<h3>Connection to Y-Combinator</h3>

	<p>The paradox function has the same self-referential structure as the Y-combinator! Both use a function that receives itself as input:</p>

	<pre><code>// Y-combinator pattern:
(x => f(x(x)))(x => f(x(x)))
     ↑    ↑         ↑    ↑
     Uses itself    Uses itself

// Paradox pattern:
paradox(paradox)
   ↑       ↑
   Calls itself with itself</code></pre>

	<p>The Y-combinator harnesses self-reference for useful recursion. The halting paradox shows that unrestricted self-reference leads to undecidability.</p>

	<h3>What This Means for Developers</h3>

	<table>
		<tr>
			<th>Impossible</th>
			<th>Possible Approximations</th>
		</tr>
		<tr>
			<td>Perfect infinite loop detection</td>
			<td>Timeouts, watchdogs</td>
		</tr>
		<tr>
			<td>Perfect deadlock detection</td>
			<td>Static analysis for common patterns</td>
		</tr>
		<tr>
			<td>Perfect optimization</td>
			<td>Heuristic optimizers</td>
		</tr>
		<tr>
			<td>Prove all programs correct</td>
			<td>Prove specific programs correct</td>
		</tr>
		<tr>
			<td>Universal virus detector</td>
			<td>Signature-based detection, heuristics</td>
		</tr>
	</table>

	<div class="info-box">
		<strong>Rice's Theorem:</strong> The halting problem is just one example. Any non-trivial property about program behavior is undecidable in general. This is why type systems, linters, and static analyzers are necessarily incomplete - they reject some valid programs or accept some invalid ones.
	</div>

	<h2>What Turing Complete Actually Means</h2>

	<p>Now that we've proven lambda calculus is Turing complete, let's clear up some common misconceptions.</p>

	<h3>Common Misconceptions</h3>

	<table>
		<tr>
			<th>Misconception</th>
			<th>Reality</th>
		</tr>
		<tr>
			<td>"More features = more powerful"</td>
			<td>A Turing complete language with 3 features computes the same things as one with 300</td>
		</tr>
		<tr>
			<td>"Languages have different computational limits"</td>
			<td>All Turing complete languages can compute exactly the same set of functions</td>
		</tr>
		<tr>
			<td>"Assembly is more powerful than Python"</td>
			<td>Both compute the same things; assembly controls <em>how</em>, not <em>what</em></td>
		</tr>
		<tr>
			<td>"Turing complete = can do anything"</td>
			<td>Can compute anything computable - but can't solve halting problem!</td>
		</tr>
		<tr>
			<td>"Need loops for computation"</td>
			<td>Recursion (or goto, or Y-combinator) works equally well</td>
		</tr>
	</table>

	<h3>The Three Essentials</h3>

	<p>A system is Turing complete with just:</p>

	<div id="demo-minimal-requirements"></div>

	<h3>Surprisingly Turing Complete</h3>

	<p>You'd be amazed what's accidentally Turing complete:</p>

	<ul>
		<li><strong>SQL (with CTEs):</strong> Recursive queries make it Turing complete</li>
		<li><strong>CSS + HTML:</strong> With Rule 110 patterns</li>
		<li><strong>PowerPoint:</strong> Yes, really - using animations and hyperlinks</li>
		<li><strong>Magic: The Gathering:</strong> The card game is Turing complete</li>
		<li><strong>Minecraft redstone:</strong> People have built working computers</li>
		<li><strong>Excel formulas:</strong> With LAMBDA function (added 2021)</li>
		<li><strong>sendmail.cf:</strong> The mail config file</li>
	</ul>

	<h3>Intentionally NOT Turing Complete</h3>

	<p>Some languages deliberately avoid Turing completeness for good reasons:</p>

	<table>
		<tr>
			<th>Language/Format</th>
			<th>Why Not Turing Complete</th>
			<th>Benefit</th>
		</tr>
		<tr>
			<td>JSON, YAML, TOML</td>
			<td>Data only, no computation</td>
			<td>Always terminates parsing</td>
		</tr>
		<tr>
			<td>Regular expressions (true regex)</td>
			<td>No unbounded memory</td>
			<td>Guaranteed to finish matching</td>
		</tr>
		<tr>
			<td>HTML (without JS)</td>
			<td>Declarative only</td>
			<td>Safe to render untrusted content</td>
		</tr>
		<tr>
			<td>SQL (basic)</td>
			<td>Originally just queries</td>
			<td>Queries always terminate</td>
		</tr>
		<tr>
			<td>Dhall</td>
			<td>Configuration language</td>
			<td>Evaluation always terminates</td>
		</tr>
		<tr>
			<td>Total languages (Agda, Idris)</td>
			<td>Require termination proofs</td>
			<td>Programs provably halt</td>
		</tr>
	</table>

	<div class="info-box">
		<strong>Design insight:</strong> Sometimes you <em>don't</em> want Turing completeness. If your configuration language is Turing complete, a malicious config could loop forever. This is why JSON beat XML for data exchange - it's simpler and guaranteed to parse.
	</div>

	<h3>Test Your Understanding</h3>

	<div id="widget-turing-quiz"></div>

	<hr style="margin: 40px 0;">

	<h3>✓ Data Storage</h3>

	<p>We have data structures built from pure functions:</p>

	<ul>
		<li><strong>Booleans:</strong> True and False for logic</li>
		<li><strong>Numbers:</strong> Church numerals for arithmetic</li>
		<li><strong>Pairs:</strong> For grouping two values</li>
		<li><strong>Lists:</strong> For storing sequences of arbitrary length</li>
	</ul>

	<pre><code>// We can store any data as functions
const myData = List([
	Pair(True)(Five),
	Pair(False)(Three),
	Pair(True)(Zero)
])</code></pre>

	<h3>✓ Conditional Logic</h3>

	<p>We have If/Then/Else using Church booleans:</p>

	<pre><code>const If = condition => thenBranch => elseBranch =>
	condition(thenBranch)(elseBranch)

// Example: absolute value
const abs = n => If(isNegative(n))
	(() => negate(n))
	(() => n)</code></pre>

	<h3>✓ Repetition (Recursion)</h3>

	<p>We have recursion through the Y combinator and thunking:</p>

	<pre><code>// Factorial demonstrates recursion
const Factorial = n => If(isZero(n))
	(() => One)
	(() => Multiply(n)(Factorial(Decrement(n))()))</code></pre>

	<h3>✓ Arbitrary Computation</h3>

	<p>We can compose these primitives to build any algorithm. For example, here's a complete program that finds prime numbers:</p>

	<div id="demo-turing-complete"></div>

	<h2>The Church-Turing Thesis</h2>

	<p>In the 1930s, two mathematicians independently proposed equivalent models of computation:</p>

	<ul>
		<li><strong>Alan Turing (1936):</strong> Turing machines - mechanical symbol manipulation</li>
		<li><strong>Alonzo Church (1936):</strong> Lambda calculus - pure function application</li>
	</ul>

	<p>The <strong>Church-Turing thesis</strong> states that these models (and others) all define the same class of computable functions. Any problem solvable by one is solvable by all.</p>

	<div class="info-box">
		<strong>Historical Note:</strong> Church was Turing's PhD advisor at Princeton. They proved their systems were equivalent, establishing the mathematical foundations of computer science before computers existed!
	</div>

	<h2>Why Lambda Calculus Matters</h2>

	<p>Lambda calculus isn't just theoretical - it directly influenced practical programming:</p>

	<h3>Functional Programming Languages</h3>

	<table>
		<tr>
			<th>Lambda Concept</th>
			<th>Modern Languages</th>
		</tr>
		<tr>
			<td>Church Booleans</td>
			<td>Boolean types, pattern matching</td>
		</tr>
		<tr>
			<td>Church Numerals</td>
			<td>Number types, fold/reduce</td>
		</tr>
		<tr>
			<td>Currying</td>
			<td>Partial application, arrow functions</td>
		</tr>
		<tr>
			<td>Composition</td>
			<td>Pipe operators, function chaining</td>
		</tr>
		<tr>
			<td>Recursion</td>
			<td>Recursive functions, tail-call optimization</td>
		</tr>
		<tr>
			<td>Pairs/Lists</td>
			<td>Tuples, lists, cons cells</td>
		</tr>
	</table>

	<h3>Languages Inspired by Lambda Calculus</h3>

	<ul>
		<li><strong>Lisp (1958):</strong> First functional language, directly based on lambda calculus</li>
		<li><strong>ML (1973):</strong> Strong type system, pattern matching</li>
		<li><strong>Haskell (1990):</strong> Pure functional, lazy evaluation, named after Haskell Curry</li>
		<li><strong>JavaScript (1995):</strong> First-class functions, closures</li>
		<li><strong>Python, Ruby, Scala, Clojure:</strong> All support functional programming patterns</li>
	</ul>

	<h2>Practical Patterns You've Learned</h2>

	<p>The techniques from lambda calculus appear everywhere in modern code:</p>

	<h3>Higher-Order Functions</h3>

	<pre><code>// JavaScript
[1, 2, 3].map(x => x * 2)        // [2, 4, 6]
[1, 2, 3].filter(x => x > 1)     // [2, 3]
[1, 2, 3].reduce((a, b) => a + b) // 6</code></pre>

	<h3>Currying and Partial Application</h3>

	<pre><code>// Creating specialized functions
const add = x => y => x + y
const add5 = add(5)
add5(3)  // 8</code></pre>

	<h3>Composition</h3>

	<pre><code>// Unix pipes are function composition!
cat file.txt | grep "error" | wc -l

// Same pattern in JavaScript
const pipeline = compose(countLines, filterErrors, readFile)</code></pre>

	<h2>Limitations and Trade-offs</h2>

	<p>While Turing complete, lambda calculus has practical limitations:</p>

	<h3>Performance</h3>

	<p>Church numerals are elegant but slow. Real languages use built-in number types optimized for hardware.</p>

	<h3>Stack Overflow</h3>

	<p>Deep recursion exceeds JavaScript's call stack. Real functional languages use tail-call optimization.</p>

	<h3>Mutability</h3>

	<p>Pure lambda calculus has no mutable state. Real programs need I/O, which requires side effects.</p>

	<div class="info-box">
		Lambda calculus proves what's <em>possible</em> theoretically. Practical languages add optimizations and features while preserving the core ideas.
	</div>

	<h2>Beyond Lambda Calculus</h2>

	<p>If you've enjoyed this journey, explore these related topics:</p>

	<h3>Theory</h3>

	<ul>
		<li><strong>Typed Lambda Calculus:</strong> Adding type systems for safety</li>
		<li><strong>Simply Typed Lambda Calculus (STLC):</strong> Basic types</li>
		<li><strong>System F:</strong> Polymorphic types</li>
		<li><strong>Dependent Types:</strong> Types that depend on values</li>
	</ul>

	<h3>Combinatory Logic</h3>

	<ul>
		<li><strong>SKI Combinator Calculus:</strong> Even simpler than lambda calculus - just three combinators!</li>
		<li><strong>S:</strong> λx.λy.λz.x z (y z)</li>
		<li><strong>K:</strong> λx.λy.x (you've met this!)</li>
		<li><strong>I:</strong> λx.x (you've met this too!)</li>
	</ul>

	<h3>Practical</h3>

	<ul>
		<li><strong>Haskell:</strong> Pure functional programming in practice</li>
		<li><strong>Category Theory:</strong> Mathematical foundations of functional programming</li>
		<li><strong>Type Theory:</strong> Connection between logic and computation</li>
		<li><strong>Proof Assistants:</strong> Coq, Agda, Lean - proving programs correct</li>
	</ul>

	<h2>Conclusion</h2>

	<p>Congratulations! You've completed the lambda calculus tutorial. You now understand:</p>

	<ul>
		<li>How to encode data as functions</li>
		<li>How to perform computation with only functions</li>
		<li>Why lambda calculus is Turing complete</li>
		<li>The theoretical foundations of functional programming</li>
		<li>How these ideas connect to modern programming languages</li>
	</ul>

	<p>Lambda calculus proves that computation requires only three things:</p>

	<ol>
		<li><strong>Variables</strong> (x, y, z)</li>
		<li><strong>Abstraction</strong> (λx.E - creating functions)</li>
		<li><strong>Application</strong> (f x - calling functions)</li>
	</ol>

	<p>Everything else - numbers, booleans, data structures, recursion, control flow - emerges from these simple foundations. This elegance is why lambda calculus remains relevant 90 years after its creation.</p>

	<div class="info-box">
		<strong>Thank you for learning with us!</strong> Lambda calculus isn't just theoretical - it's the foundation of modern functional programming. The patterns you've learned directly apply to real-world code in JavaScript, Python, Haskell, and beyond. You're now equipped to recognize these patterns and use them to write clearer, more composable code.
	</div>

	<div class="chapter-nav">
		<a href="06-recursion.html">← Chapter 6: Recursion</a>
		<a href="../index.html">Home</a>
	</div>

	<div style="margin-top: 3rem;">
		<div style="font-size: 0.85rem; font-style: italic; color: #666; border-left: 3px solid #e0e0e0; padding-left: 1rem; margin-bottom: 0.75rem;">
			<p>* Warning: May contain uncomputability**</p>
		</div>

		<div style="font-size: 0.85rem; font-style: italic; color: #666; border-left: 3px solid #e0e0e0; padding-left: 1rem; margin-bottom: 0.75rem;">
			<p>** Side effects may include infinite recursion and existential dread***</p>
		</div>

		<div style="font-size: 0.85rem; font-style: italic; color: #666; border-left: 3px solid #e0e0e0; padding-left: 1rem;">
			<p>*** Not to be read more than once</p>
		</div>
	</div>

	<script type="module">
		import { InteractiveDemo } from '../js/interactive.js'
		import { Y } from '../lib/combinators.js'

		const demo = new InteractiveDemo()

		// Y-Combinator step-by-step reduction demo
		demo.registerDemo('demo-y-combinator-reduction', () => {
			return {
				steps: [
					{
						label: 'Start with Y f',
						expression: 'Y f',
						explanation: 'We want to find the fixed point of f'
					},
					{
						label: 'Expand Y definition',
						expression: '(λx.f(x x))(λx.f(x x))',
						explanation: 'Y = λf.(λx.f(x x))(λx.f(x x))',
						highlight: 'λx.f(x x)'
					},
					{
						label: 'Apply left λx to right λx',
						expression: 'f((λx.f(x x))(λx.f(x x)))',
						explanation: 'Substitute the right side for x in the left side'
					},
					{
						label: 'Notice the pattern',
						expression: 'f(Y f)',
						explanation: 'The inner part is Y f again! So Y f = f(Y f)',
						highlight: 'Y f'
					},
					{
						label: 'The fixed point property',
						expression: 'Y f = f(Y f) = f(f(Y f)) = f(f(f(...)))',
						explanation: 'Y f equals f applied infinitely - perfect for recursion!'
					}
				]
			}
		})

		// Y-combinator factorial demo
		demo.registerDemo('demo-y-factorial', () => {
			// Define factorial maker
			const factorialMaker = recurse => n =>
				n === 0 ? 1 : n * recurse(n - 1)

			// Create factorial using Y-combinator
			const factorial = Y(factorialMaker)

			// Compute some examples
			const examples = [0, 1, 2, 3, 4, 5].map(n => ({
				input: n,
				output: factorial(n)
			}))

			let html = `<strong>Y(factorialMaker) computes:</strong><br><br>`
			html += `<code style="display: block; background: #f5f5f5; padding: 15px; border-radius: 4px;">`
			html += `const factorialMaker = recurse => n =><br>`
			html += `&nbsp;&nbsp;n === 0 ? 1 : n * recurse(n - 1)<br><br>`
			html += `const factorial = Y(factorialMaker)</code><br><br>`
			html += `<strong>Results:</strong><br>`
			examples.forEach(({input, output}) => {
				html += `factorial(${input}) = ${output}<br>`
			})
			return html
		})

		// Y-combinator interactive widget
		demo.registerWidget('widget-y-combinator', {
			inputs: [
				{ name: 'fn', label: 'Function:', type: 'text', default: 'factorial' },
				{ name: 'n', label: 'Input n:', min: 0, max: 12, default: 5 }
			],
			maxValue: 12,
			compute: ({ fn, n }) => {
				const functions = {
					factorial: {
						maker: recurse => x => x === 0 ? 1 : x * recurse(x - 1),
						desc: 'n! = n × (n-1) × ... × 1'
					},
					sum: {
						maker: recurse => x => x === 0 ? 0 : x + recurse(x - 1),
						desc: '1 + 2 + ... + n'
					},
					fibonacci: {
						maker: recurse => x => x <= 1 ? x : recurse(x - 1) + recurse(x - 2),
						desc: 'fib(n) = fib(n-1) + fib(n-2)'
					},
					countdown: {
						maker: recurse => x => x === 0 ? 'done!' : `${x}...${recurse(x - 1)}`,
						desc: 'n, n-1, ..., done!'
					}
				}

				const key = fn.toLowerCase().trim()
				const selected = functions[key]

				if (!selected) {
					return `Unknown function "${fn}". Try: factorial, sum, fibonacci, countdown`
				}

				// Limit fibonacci due to exponential complexity
				if (key === 'fibonacci' && n > 10) {
					return `Fibonacci limited to n ≤ 10 (exponential calls). Try a smaller number.`
				}

				const recursive = Y(selected.maker)
				const result = recursive(n)
				return {
					'Function': key,
					'Formula': selected.desc,
					[`Y(${key}Maker)(${n})`]: result
				}
			}
		})

		// Minimal requirements demo
		demo.registerDemo('demo-minimal-requirements', () => {
			return `
				<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center;">
					<div style="background: #e3f2fd; padding: 20px; border-radius: 8px; border: 2px solid #2196F3;">
						<div style="font-size: 24px; margin-bottom: 10px;">1</div>
						<strong>Conditionals</strong><br>
						<span style="font-size: 0.9em; color: #666;">if/then/else</span>
					</div>
					<div style="background: #e8f5e9; padding: 20px; border-radius: 8px; border: 2px solid #4CAF50;">
						<div style="font-size: 24px; margin-bottom: 10px;">2</div>
						<strong>Unbounded Memory</strong><br>
						<span style="font-size: 0.9em; color: #666;">store arbitrary data</span>
					</div>
					<div style="background: #fff3e0; padding: 20px; border-radius: 8px; border: 2px solid #FF9800;">
						<div style="font-size: 24px; margin-bottom: 10px;">3</div>
						<strong>Unbounded Looping</strong><br>
						<span style="font-size: 0.9em; color: #666;">recursion or iteration</span>
					</div>
				</div>
				<p style="margin-top: 15px; text-align: center; color: #666; font-style: italic;">
					With just these three capabilities, you can compute anything that's computable.
				</p>
			`
		})

		// Turing completeness quiz widget
		demo.registerWidget('widget-turing-quiz', {
			inputs: [
				{
					name: 'language',
					label: 'Is this Turing complete?',
					type: 'text',
					default: 'JSON'
				}
			],
			compute: ({ language }) => {
				const turingComplete = {
					'javascript': { complete: true, reason: 'Has loops, conditionals, and unbounded memory (heap)' },
					'python': { complete: true, reason: 'General-purpose language with all requirements' },
					'c': { complete: true, reason: 'Can allocate memory, loop, and branch' },
					'haskell': { complete: true, reason: 'Recursion and lazy infinite structures' },
					'sql': { complete: true, reason: 'With recursive CTEs (since SQL:1999)' },
					'css': { complete: true, reason: 'Can simulate Rule 110 cellular automaton' },
					'html': { complete: false, reason: 'Declarative markup only, no computation' },
					'json': { complete: false, reason: 'Pure data format, no computation' },
					'yaml': { complete: false, reason: 'Data serialization, no computation' },
					'xml': { complete: false, reason: 'Markup only (XSLT is Turing complete though!)' },
					'regex': { complete: false, reason: 'True regular expressions have no unbounded memory' },
					'brainfuck': { complete: true, reason: 'Just 8 commands but Turing complete!' },
					'lambda calculus': { complete: true, reason: "That's what this whole tutorial proved!" },
					'excel': { complete: true, reason: 'LAMBDA function (2021) made it Turing complete' },
					'powerpoint': { complete: true, reason: 'Hyperlinks + animations can simulate computation' },
					'minecraft': { complete: true, reason: 'Redstone circuits can build computers' },
					'typescript': { complete: true, reason: 'The type system alone is Turing complete!' },
				}

				const key = language.toLowerCase().trim()
				const info = turingComplete[key]

				if (info) {
					const emoji = info.complete ? '✓' : '✗'
					const color = info.complete ? '#4CAF50' : '#f44336'
					return `<span style="color: ${color}; font-weight: bold;">${emoji} ${info.complete ? 'Yes' : 'No'}</span><br>${info.reason}`
				} else {
					return `I don't have info on "${language}". Try: JavaScript, Python, JSON, HTML, SQL, CSS, regex, Brainfuck, or Excel.`
				}
			}
		})

		// Demonstrate Turing completeness with a simple example
		demo.registerDemo('demo-turing-complete', () => {
			return `
				Lambda calculus can implement any algorithm, including:<br>
				<br>
				• Prime number checking<br>
				• Fibonacci sequence<br>
				• Sorting algorithms<br>
				• Graph traversal<br>
				• Even a lambda calculus interpreter in lambda calculus!<br>
				<br>
				If it's computable, lambda calculus can compute it.
			`
		})

		demo.runDemos()
		demo.setupWidgets()
	</script>
</body>
</html>
